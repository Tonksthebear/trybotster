// src/main.rs
use anyhow::{Context, Result};
use clap::Parser;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use portable_pty::{native_pty_system, Command, NativePtySystem, PtySize};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, Paragraph, Wrap},
    Frame, Terminal,
};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::{
    collections::VecDeque,
    env,
    fs::{self, File},
    io::{self, BufRead, BufReader, Write},
    path::PathBuf,
    process::{Command as ProcessCommand, Stdio},
    sync::{Arc, Mutex},
    thread,
    time::{Duration, Instant},
};
use tokio::sync::mpsc;
use tokio::time::interval;

// Configuration
#[derive(Serialize, Deserialize, Clone, Default)]
struct Config {
    server_url: String,
    api_key: String,
    agent_command: String,
    poll_interval: u64,
    agent_timeout: u64,
    max_sessions: usize,
    worktree_base: PathBuf,
    claude_permission_mode: String,
    claude_allowed_tools: String,
    preserve_agent_ansi: bool,
}

impl Config {
    fn load() -> Result<Self> {
        let config_dir = dirs::home_dir().context("No home dir")?.join(".botster_hub");
        fs::create_dir_all(&config_dir)?;
        let config_path = config_dir.join("config.json");
        if config_path.exists() {
            let content = fs::read_to_string(&config_path)?;
            Ok(serde_json::from_str(&content)?)
        } else {
            let default = Self::default();
            fs::write(&config_path, serde_json::to_string_pretty(&default)?)?;
            Ok(default)
        }
    }

    fn save(&self) -> Result<()> {
        let config_dir = dirs::home_dir().context("No home dir")?.join(".botster_hub");
        let config_path = config_dir.join("config.json");
        fs::write(&config_path, serde_json::to_string_pretty(self)?)?;
        Ok(())
    }
}

// Agent
#[derive(Clone)]
struct Agent {
    id: uuid::Uuid,
    repo: String,
    issue_number: u32,
    worktree_path: PathBuf,
    start_time: chrono::DateTime<chrono::Utc>,
    status: AgentStatus,
    pty: Option<portable_pty::Child>,
    buffer: Arc<Mutex<VecDeque<String>>>,
    alive: Arc<Mutex<bool>>,
}

#[derive(Clone, PartialEq)]
enum AgentStatus {
    Initializing,
    Spawning,
    Running,
    Finished,
    Failed(String),
    Killed,
}

impl Agent {
    fn new(id: uuid::Uuid, repo: String, issue_number: u32, worktree_path: PathBuf) -> Self {
        Self {
            id,
            repo,
            issue_number,
            worktree_path,
            start_time: chrono::Utc::now(),
            status: AgentStatus::Initializing,
            pty: None,
            buffer: Arc::new(Mutex::new(VecDeque::new())),
            alive: Arc::new(Mutex::true()),
        }
    }

    fn spawn(&mut self, command: &str, context: &str, config: &Config) -> Result<()> {
        let pty_system = native_pty_system();
        let size = PtySize {
            rows: 24,
            cols: 80,
            pixel_width: 0,
            pixel_height: 0,
        };
        let mut pty = pty_system.openpty(size)?;
        let mut cmd = ProcessCommand::new(&config.agent_command);
        cmd.args(command.split_whitespace())
            .current_dir(&self.worktree_path)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());
        let child = pty_system.spawn_command(cmd, &mut pty)?;

        self.pty = Some(child);
        self.status = AgentStatus::Running;

        // Send context
        if !context.is_empty() {
            pty.write_all(context.as_bytes())?;
            pty.write_all(b"\n")?;
        }

        Ok(())
    }

    fn write(&mut self, input: &str) -> Result<()> {
        if let Some(child) = &mut self.pty {
            let mut pty = child.pty_mut();
            pty.write_all(input.as_bytes())?;
        }
        Ok(())
    }

    fn read_output(&mut self) -> Result<()> {
        if let Some(child) = &mut self.pty {
            let mut pty = child.pty_mut();
            let mut buf = [0; 4096];
            match pty.read(&mut buf) {
                Ok(0) => {
                    *self.alive.lock().unwrap() = false;
                    self.status = AgentStatus::Finished;
                }
                Ok(n) => {
                    let output = String::from_utf8_lossy(&buf[..n]);
                    let lines: Vec<String> = output.lines().map(|l| l.to_string()).collect();
                    let mut buffer = self.buffer.lock().unwrap();
                    for line in lines {
                        buffer.push_back(line);
                        if buffer.len() > 10000 {
                            buffer.pop_front();
                        }
                    }
                }
                Err(_) => {
                    *self.alive.lock().unwrap() = false;
                }
            }
        }
        Ok(())
    }

    fn kill(&mut self) {
        if let Some(child) = &mut self.pty {
            let _ = child.kill();
        }
        *self.alive.lock().unwrap() = false;
        self.status = AgentStatus::Killed;
    }

    fn age(&self) -> Duration {
        chrono::Utc::now().signed_duration_since(self.start_time).to_std().unwrap_or_default()
    }
}

// App State
struct App {
    agents: Vec<Agent>,
    selected: usize,
    config: Config,
    client: Client,
    should_quit: bool,
    input_mode: bool,
    input_buffer: String,
    log_scroll: usize,
}

impl App {
    fn new() -> Result<Self> {
        let config = Config::load()?;
        let client = Client::new();
        Ok(Self {
            agents: Vec::new(),
            selected: 0,
            config,
            client,
            should_quit: false,
            input_mode: false,
            input_buffer: String::new(),
            log_scroll: 0,
        })
    }

    fn poll_messages(&mut self) -> Result<()> {
        let url = format!("{}/bots/messages?repo={}", self.config.server_url, /* detect repo */ "example");
        let resp = self.client.get(&url).header("X-API-Key", &self.config.api_key).send_await()?;
        if resp.status().is_success() {
            let messages: Vec<Message> = resp.json_await()?;
            for msg in messages {
                if let Err(e) = self.process_message(msg) {
                    log::error!("Process error: {}", e);
                }
            }
        }
        Ok(())
    }

    fn process_message(&mut self, msg: Message) -> Result<()> {
        // Simplified - spawn agent if github_mention
        let id = uuid::Uuid::new_v4();
        let worktree = self.create_worktree(&msg.repo, msg.issue_number)?;
        let mut agent = Agent::new(id, msg.repo, msg.issue_number, worktree);
        let command = self.build_command(&worktree);
        agent.spawn(&command, &msg.context, &self.config)?;
        self.agents.push(agent);
        Ok(())
    }

    fn create_worktree(&self, repo: &str, issue: u32) -> Result<PathBuf> {
        // Use git2 to clone and create worktree
        let repo_safe = repo.replace('/', "-");
        let base = &self.config.worktree_base;
        let clone_dir = base.join(&repo_safe);
        if !clone_dir.exists() {
            git2::build::RepoBuilder::new()
                .clone(&format!("https://github.com/{}.git", repo), &clone_dir)?;
        }
        let repo = git2::Repository::open(&clone_dir)?;
        let branch = format!("botster-{}-{}", repo_safe, issue);
        let worktree_path = base.join(format!("{}-{}", repo_safe, issue));
        repo.worktree(&branch, &worktree_path, Some(&branch), None)?;
        Ok(worktree_path)
    }

    fn build_command(&self, path: &PathBuf) -> String {
        let mut cmd = self.config.agent_command.clone();
        if self.config.agent_command == "claude" {
            cmd.push_str(&format!(" --permission-mode {} --allowedTools {} --add-dir {}",
                self.config.claude_permission_mode, self.config.claude_allowed_tools, path.display()));
        }
        cmd
    }

    fn on_key(&mut self, key: crossterm::event::KeyCode) {
        match key {
            KeyCode::Char('q') => self.should_quit = true,
            KeyCode::Char('i') if !self.input_mode => self.input_mode = true,
            KeyCode::Char('k') | KeyCode::Up => {
                if self.selected > 0 {
                    self.selected -= 1;
                }
            }
            KeyCode::Char('j') | KeyCode::Down => {
                if self.selected < self.agents.len().saturating_sub(1) {
                    self.selected += 1;
                }
            }
            KeyCode::Char('K') => {
                if let Some(agent) = self.agents.get_mut(self.selected) {
                    agent.kill();
                }
            }
            KeyCode::Enter if self.input_mode => {
                if let Some(agent) = self.agents.get_mut(self.selected) {
                    let _ = agent.write(&format!("{}\n", self.input_buffer));
                }
                self.input_buffer.clear();
                self.input_mode = false;
            }
            KeyCode::Backspace if self.input_mode && !self.input_buffer.is_empty() => {
                self.input_buffer.pop();
            }
            KeyCode::Char(c) if self.input_mode => {
                self.input_buffer.push(c);
            }
            _ => {}
        }
    }
}

// Message struct (simplified)
#[derive(Deserialize)]
struct Message {
    repo: String,
    issue_number: u32,
    context: String,
}

// TUI
fn setup_terminal() -> Result<Terminal<CrosstermBackend<io::Stdout>>> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    Terminal::new(CrosstermBackend::new(stdout))?.apply(|t| Ok(t.clear()?))
}

fn restore_terminal() -> Result<()> {
    disable_raw_mode()?;
    execute!(io::stdout(), LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
}

fn main() -> Result<()> {
    env_logger::init();
    let args = clap::Parser::parse::<Cli>();
    match args.command {
        CliCommand::Start { headless } => {
            if headless {
                // Headless mode
                let mut app = App::new()?;
                let rt = tokio::runtime::Runtime::new()?;
                rt.block_on(async {
                    let mut interval = interval(Duration::from_secs(app.config.poll_interval));
                    loop {
                        app.poll_messages().await.unwrap();
                        // Monitor agents
                        interval.tick().await;
                    }
                });
            } else {
                // Interactive TUI
                let mut terminal = setup_terminal()?;
                let mut app = App::new()?;

                let tick_rate = Duration::from_millis(250);
                let mut last_tick = Instant::now();

                loop {
                    terminal.draw(|f| ui(f, &mut app))?;

                    let timeout = tick_rate
                        .checked_sub(last_tick.elapsed())
                        .unwrap_or_else(|| Duration::from_secs(0));

                    if crossterm::event::poll(timeout)? {
                        if let Event::Key(key) = event::read()? {
                            if key.kind == KeyEventKind::Press {
                                app.on_key(key.code);
                            }
                            if app.should_quit {
                                return Ok(());
                            }
                        }
                    }

                    if last_tick.elapsed() >= tick_rate {
                        // Poll
                        if let Ok(_) = app.poll_messages() {
                            // Update
                        }
                        for agent in &mut app.agents {
                            let _ = agent.read_output();
                        }
                        last_tick = Instant::now();
                    }
                }
            }
        }
        _ => println!("Other commands not implemented"),
    }
}

fn ui(f: &mut Frame<CrosstermBackend<io::Stdout>>, app: &mut App) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(30), Constraint::Percentage(70)].as_ref())
        .split(f.size());

    // Left panel: Agent list
    let agents: Vec<ListItem> = app.agents.iter().map(|a| {
        ListItem::new(Line::from(vec![
            Span::raw(format!("[{}] ", a.id.to_string()[..8].to_string())),
            Span::raw(format!("{}#{} ", a.repo.split('/').last().unwrap_or(""), a.issue_number)),
            Span::styled(
                format_age(a.age()),
                if matches!(a.status, AgentStatus::Running) {
                    Style::default().fg(Color::Green)
                } else {
                    Style::default().fg(Color::Red)
                },
            ),
        ]))
    }).collect();
    let list = List::new(agents)
        .block(Block::default().title("Agents").borders(Borders::ALL))
        .highlight_style(Style::default().add_modifier(Modifier::BOLD))
        .highlight_symbol(">");
    f.render_stateful_widget(list, chunks[0], &mut app.selected.into());

    // Right panel: Log/REPL
    let selected = app.agents.get(app.selected).cloned();
    if let Some(agent) = selected {
        let mut buffer = agent.buffer.lock().unwrap();
        let lines: Vec<Line> = buffer.iter().skip(app.log_scroll).cloned().map(Line::from).collect();
        let p = Paragraph::new(lines)
            .block(Block::default().title(format!("{}##{}", agent.repo, agent.issue_number)).borders(Borders::ALL))
            .wrap(Wrap::default());
        f.render_widget(p, chunks[1]);

        if app.input_mode {
            let input = Paragraph::new(app.input_buffer.as_str())
                .style(Style::default().fg(Color::Yellow))
                .block(Block::default().borders(Borders::ALL).title("Input"));
            f.render_widget(input, chunks[1].split(Constraint::Length(3))[1]);
        }
    } else {
        let block = Paragraph::new("No agents").block(Block::default().borders(Borders::ALL));
        f.render_widget(block, chunks[1]);
    }
}

fn format_age(age: Duration) -> String {
    let secs = age.as_secs();
    if secs < 60 {
        format!("{}s", secs)
    } else if secs < 3600 {
        format!("{}m", secs / 60)
    } else {
        format!("{}h", secs / 3600)
    }
}

// CLI
#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: CliCommand,
}

#[derive(clap::Subcommand)]
enum CliCommand {
    Start { #[arg(long)] headless: bool },
    // Add other commands: status, kill, etc.
}
