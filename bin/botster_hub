#!/usr/bin/env ruby
# frozen_string_literal: true

# Botster Hub - Interactive PTY-based daemon for GitHub mention → local agent automation
# ZERO gem dependencies - uses only Ruby 2.7+ standard library

require 'net/http'
require 'uri'
require 'json'
require 'pty'
require 'io/wait'
require 'io/console'
require 'fileutils'
require 'logger'
require 'time'
require 'shellwords'
require 'stringio'

VERSION = '0.4.0'  # Bumped for updates

# ============================================================================
# ANSI Terminal Control (zero dependencies!)
# ============================================================================

module ANSI
  # Cursor control
  CLEAR_SCREEN = "\e[2J"
  CLEAR_LINE = "\e[2K"
  HIDE_CURSOR = "\e[?25l"
  SHOW_CURSOR = "\e[?25h"
  SAVE_CURSOR = "\e[s"
  RESTORE_CURSOR = "\e[u"
  HOME = "\e[H"

  # Colors
  RESET = "\e[0m"
  BOLD = "\e[1m"
  DIM = "\e[2m"

  GREEN = "\e[32m"
  YELLOW = "\e[33m"
  RED = "\e[31m"
  CYAN = "\e[36m"

  def self.move(row, col)
    "\e[#{row};#{col}H"
  end

  def self.color(text, color_code)
    "#{color_code}#{text}#{RESET}"
  end

  def self.terminal_size
    rows, cols = $stdout.winsize
    [rows, cols]
  rescue
    [24, 80]
  end
end

# ============================================================================
# Configuration (edit these values)
# ============================================================================

CONFIG_DIR = File.join(ENV['HOME'], '.botster_hub')
CONFIG_FILE = File.join(CONFIG_DIR, 'config.json')
SESSIONS_FILE = File.join(CONFIG_DIR, 'sessions.json')
LOG_FILE = File.join(CONFIG_DIR, 'botster_hub.log')
PID_FILE = File.join(CONFIG_DIR, 'botster_hub.pid')

DEFAULT_CONFIG = {
  server_url: 'http://localhost:3000',
  api_key: '',
  agent_command: 'claude',
  poll_interval: 5,        # seconds between polls
  agent_timeout: 3600,     # auto-kill agents after 1 hour
  max_sessions: 20,
  worktree_base: File.join(ENV['HOME'], 'botster-sessions'),
  completion_marker: '.botster_status',
  claude_permission_mode: 'acceptEdits',
  claude_allowed_tools: 'mcp__*',
  preserve_agent_ansi: false  # New: If true, keep agent's ANSI (risky, may break TUI)
}.freeze

# ============================================================================
# Agent Class - Manages a single Claude Code PTY session
# ============================================================================

class Agent
  attr_reader :id, :repo, :issue_number, :worktree_path, :start_time, :status
  attr_accessor :buffer

  MAX_BUFFER_LINES = 20000  # Increased for more history

  ANSI_STRIP_REGEX = /\x1B(?:[@-Z\\-_]|\[[0-?]*[ -\/]*[@-~])/  # For stripping agent ANSI

  def initialize(id, repo, issue_number, worktree_path, preserve_ansi)
    @id = id
    @repo = repo
    @issue_number = issue_number
    @worktree_path = worktree_path
    @start_time = Time.now
    @status = 'initializing'
    @buffer = []
    @pty_master = nil
    @pty_slave = nil
    @pid = nil
    @dead = false
    @preserve_ansi = preserve_ansi
  end

  def spawn_agent(command, context)
    @status = 'spawning'

    begin
      @pty_master, @pty_slave = PTY.open
      @pty_slave.winsize = [24, 80]  # Small size to discourage full TUI
      @pid = Process.spawn(
        { 'TERM' => 'dumb' },
        command,
        in: @pty_slave,
        out: @pty_slave,
        err: @pty_slave,
        chdir: @worktree_path
      )
      @pty_slave.close
      @status = 'running'
      @pty_master.sync = true

      add_to_buffer("==> Agent spawned: #{@repo}##{@issue_number}")
      add_to_buffer("==> PID: #{@pid}")
      add_to_buffer("==> Command: #{command}")
      add_to_buffer("==> Worktree: #{@worktree_path}")
      add_to_buffer("")

      sleep 0.5
      if context && !context.empty?
        add_to_buffer("==> Sending context to agent...")
        write("#{context}\n")
      end

      true
    rescue StandardError => e
      @status = 'failed'
      add_to_buffer("ERROR: Failed to spawn agent: #{e.message}")
      false
    end
  end

  def read_output
    return unless @pty_master && !@pty_master.closed?

    begin
      data_read = false
      loop do
        break unless @pty_master.ready?

        chunk = @pty_master.read_nonblock(4096)
        break if chunk.nil? || chunk.empty?

        data_read = true
        chunk.each_line do |line|
          add_to_buffer(line.chomp)
        end
        break if chunk.length < 4096
      end
    rescue IO::WaitReadable, IO::EAGAINWaitReadable
      # Normal
    rescue Errno::EIO, EOFError
      @status = 'finished'
      add_to_buffer("==> Agent finished")
      close
    rescue StandardError => e
      add_to_buffer("ERROR reading output: #{e.message}")
    end
  end

  def write(input)
    return unless @pty_master && !@pty_master.closed?
    add_to_buffer("==> Sending input: #{input.inspect}")
    @pty_master.write(input)
    @pty_master.flush
  rescue StandardError => e
    add_to_buffer("ERROR writing input: #{e.message}")
  end

  def alive?
    return false if @dead || !@pid.is_a?(Integer)
    Process.kill(0, @pid)
    true
  rescue Errno::ESRCH, Errno::EPERM
    @dead = true
    false
  end

  def kill
    return unless @pid.is_a?(Integer)
    @status = 'killed'
    add_to_buffer("==> Killing agent...")
    Process.kill('TERM', @pid)
    sleep 0.5
    Process.kill('KILL', @pid) if alive?
    close
  rescue Errno::ESRCH
    # Already dead
  ensure
    close
  end

  def close
    @pty_master.close if @pty_master && !@pty_master.closed?
    @pty_master = nil
  end

  def age
    Time.now - @start_time
  end

  def session_key
    @repo.gsub('/', '-') + "-#{@issue_number}"
  end

  def to_h
    {
      id: @id,
      repo: @repo,
      issue_number: @issue_number,
      worktree_path: @worktree_path,
      start_time: @start_time.iso8601,
      status: @status,
      pid: @pid
    }
  end

  private

  def add_to_buffer(line)
    cleaned = @preserve_ansi ? line : line.gsub(ANSI_STRIP_REGEX, '')
    @buffer << cleaned
    @buffer.shift if @buffer.size > MAX_BUFFER_LINES
  end
end

# ============================================================================
# BotsterHub - Main daemon
# ============================================================================

class BotsterHub
  attr_reader :agents, :config

  def initialize
    FileUtils.mkdir_p(CONFIG_DIR)
    load_config
    setup_logger
    @agents = []
    @next_id = 1
    @mutex = Mutex.new
    @running = true
  end

  def run(args)
    command = args[0]

    case command
    when 'start'
      start_daemon(args)
    when 'status'
      cmd_status
    when 'kill'
      cmd_kill(args[1])
    when 'cleanup'
      cmd_cleanup
    when 'config'
      cmd_config(args[1], args[2])
    when 'version', '--version', '-v'
      puts "Botster Hub v#{VERSION}"
    when 'help', '--help', '-h', nil
      cmd_help
    else
      puts "Unknown command: #{command}"
      puts "Run 'botster_hub help' for usage"
      exit 1
    end
  end

  private

  def load_config
    @config = File.exist?(CONFIG_FILE) ? JSON.parse(File.read(CONFIG_FILE), symbolize_names: true) : DEFAULT_CONFIG.dup
    save_config unless File.exist?(CONFIG_FILE)
  end

  def save_config
    File.write(CONFIG_FILE, JSON.pretty_generate(@config))
  end

  def setup_logger
    @logger = Logger.new(LOG_FILE, 10, 1024000)
    @logger.level = Logger::INFO
  end

  def log(msg)
    @logger.info(msg) if @logger
  end

  def start_daemon(args)
    if running?
      puts "Botster Hub is already running (PID: #{File.read(PID_FILE).strip})"
      exit 1
    end

    unless system('git rev-parse --git-dir > /dev/null 2>&1')
      puts "ERROR: Not in a git repository"
      exit 1
    end

    File.write(PID_FILE, Process.pid.to_s)

    headless = args.include?('--headless') || !$stdout.tty?

    trap('INT') { @running = false }
    trap('TERM') { @running = false }
    trap('WINCH') { @terminal_resized = true }  # Just set a flag, handle in main loop

    log "Starting Botster Hub v#{VERSION} (#{headless ? 'headless' : 'interactive'})"

    if headless
      run_headless
    else
      run_interactive
    end
  end

  def run_headless
    puts "Starting in headless mode... (press Ctrl+C to stop)"
    log "Running in headless mode"

    poll_interval = @config[:poll_interval] || 5

    loop do
      break unless @running
      poll_and_spawn
      @mutex.synchronize { @agents.each(&:read_output); cleanup_agents }
      sleep poll_interval
    end

    cleanup_all_agents
    File.delete(PID_FILE) if File.exist?(PID_FILE)
    puts "\nShutdown complete"
  end

  def run_interactive
    begin
      print ANSI::HIDE_CURSOR
      print ANSI::CLEAR_SCREEN

      $stdin.raw!

      @selected_index = 0
      @log_scroll = 0
      @terminal_height, @terminal_width = ANSI.terminal_size
      @list_width = [@terminal_width / 3, 40].min
      @input_mode = false
      @input_buffer = ""
      @input_cursor_pos = 0
      @input_history = []  # Up to 10 lines
      @input_history_index = 0

      start_poll_thread

      io_loop  # New select-based loop
    ensure
      $stdin.cooked! rescue nil
      print ANSI::SHOW_CURSOR
      print ANSI::CLEAR_SCREEN
      print ANSI::HOME

      @running = false
      cleanup_all_agents
      File.delete(PID_FILE) if File.exist?(PID_FILE)
    end
  end

  def start_poll_thread
    @poll_thread = Thread.new do
      loop do
        break unless @running
        poll_and_spawn
        sleep(@config[:poll_interval] || 5)
      end
    rescue StandardError => e
      log "Poll thread error: #{e.message}"
    end
  end

  def io_loop
    loop do
      break unless @running

      @mutex.synchronize do
        ios = @agents.map { |a| a.instance_variable_get(:@pty_master) }.compact + [$stdin]
        readable, _, _ = IO.select(ios, nil, nil, 0.1)  # Timeout for redraws

        if readable
          readable.each do |io|
            if io == $stdin
              ch = io.getc
              if @input_mode
                handle_input_mode(ch)
              else
                handle_navigation_mode(ch)
              end
            else
              agent = @agents.find { |a| a.instance_variable_get(:@pty_master) == io }
              agent.read_output if agent
            end
          end
        end

        cleanup_agents
      end

      # Handle resize if needed
      if @terminal_resized
        @terminal_height, @terminal_width = ANSI.terminal_size
        @list_width = [@terminal_width / 3, 40].min
        @terminal_resized = false
      end

      draw_ui
    end
  end

  def handle_navigation_mode(ch)
    esc_seq = ""
    if ch == "\e"
      esc_seq = ch + $stdin.read_nonblock(10) rescue ch  # Read full escape seq
    else
      esc_seq = ch
    end

    case esc_seq
    when "\e[A", 'k'  # Up
      old_index = @selected_index
      @selected_index = [@selected_index - 1, 0].max
      @log_scroll = Float::INFINITY if old_index != @selected_index  # Will be clamped to max
    when "\e[B", 'j'  # Down
      old_index = @selected_index
      @selected_index = [@selected_index + 1, @agents.size - 1].max
      @log_scroll = Float::INFINITY if old_index != @selected_index  # Will be clamped to max
    when "\e[5~"  # Page Up
      @log_scroll = [@log_scroll - 10, 0].max
    when "\e[6~"  # Page Down
      if (selected = _selected_agent_unsafe)
        max_scroll = [selected.buffer.size - (@terminal_height - 2), 0].max
        @log_scroll = [@log_scroll + 10, max_scroll].min
      end
    when 'u'  # Scroll up 1 line
      @log_scroll = [@log_scroll - 1, 0].max
    when 'd'  # Scroll down 1 line
      if (selected = _selected_agent_unsafe)
        max_scroll = [selected.buffer.size - (@terminal_height - 2), 0].max
        @log_scroll = [@log_scroll + 1, max_scroll].min
      end
    when 'K'
      # Don't call kill_selected_agent as it tries to acquire mutex
      agent = _selected_agent_unsafe
      if agent
        agent.kill
        cleanup_session(agent)
      end
    when 'i', 'I'
      # Only enter input mode if there's an agent selected
      if _selected_agent_unsafe
        @input_mode = true
        @input_buffer = ""
        @input_cursor_pos = 0
        @input_history_index = @input_history.size
      end
    when 'q', 'Q', "\x03"
      @running = false
    when 'h', 'H'
      # Show help (overlay)
      print ANSI::SAVE_CURSOR
      print ANSI.color("Help: j/k nav, i input, K kill, u/d scroll, q quit", ANSI::YELLOW)
      sleep 2
      print ANSI::RESTORE_CURSOR
    when 'r', 'R'
      # Refresh
    end
  end

  def handle_input_mode(ch)
    log "handle_input_mode called: ch=#{ch.inspect}, input_mode=#{@input_mode}, buffer=#{@input_buffer.inspect}"

    esc_seq = ""
    if ch == "\e"
      esc_seq = ch + ($stdin.read_nonblock(10) rescue "")
    else
      esc_seq = ch
    end

    log "handle_input_mode: esc_seq=#{esc_seq.inspect}"

    case esc_seq
    when "\e"  # Escape alone - exit mode
      log "handle_input_mode: ESC pressed - exiting input mode"
      @input_mode = false
      @input_buffer = ""
    when "\r", "\n"  # Enter
      log "handle_input_mode: ENTER pressed - buffer=#{@input_buffer.inspect}"
      agent = _selected_agent_unsafe
      if agent
        if !@input_buffer.empty?
          agent.write("#{@input_buffer}\n")
          @input_history << @input_buffer
          @input_history.shift if @input_history.size > 10
        else
          agent.add_to_buffer("==> (empty input, not sent)")
        end
      else
        # No agent selected - can't happen but just in case
      end
      @input_mode = false
      @input_buffer = ""
      @input_cursor_pos = 0
    when "\x7F", "\x08", "\e[3~"  # Backspace/Delete
      if @input_cursor_pos > 0
        @input_buffer = @input_buffer[0...@input_cursor_pos - 1] + @input_buffer[@input_cursor_pos..]
        @input_cursor_pos -= 1
      end
    when "\x03"  # Ctrl+C
      @input_mode = false
      @input_buffer = ""
    when "\e[A"  # Up (history)
      if @input_history_index > 0
        @input_history_index -= 1
        @input_buffer = @input_history[@input_history_index]
        @input_cursor_pos = @input_buffer.length
      end
    when "\e[B"  # Down (history)
      if @input_history_index < @input_history.size
        @input_history_index += 1
        @input_buffer = @input_history_index < @input_history.size ? @input_history[@input_history_index] : ""
        @input_cursor_pos = @input_buffer.length
      end
    when "\e[D"  # Left
      @input_cursor_pos = [@input_cursor_pos - 1, 0].max
    when "\e[C"  # Right
      @input_cursor_pos = [@input_cursor_pos + 1, @input_buffer.length].min
    when "\e[H", "\e[1~"  # Home
      @input_cursor_pos = 0
    when "\e[F", "\e[4~"  # End
      @input_cursor_pos = @input_buffer.length
    else
      if ch.match?(/[[:print:]]/)
        @input_buffer = @input_buffer[0...@input_cursor_pos] + ch + @input_buffer[@input_cursor_pos..]
        @input_cursor_pos += 1
      end
    end
  end

  def draw_ui
    output = StringIO.new
    output.print ANSI::CLEAR_SCREEN
    output.print ANSI::HOME

    draw_agent_list(output)
    draw_log_view(output)

    print output.string
    $stdout.flush
  end

  def draw_agent_list(output)
    (1..@terminal_height).each do |row|
      output.print ANSI.move(row, 1)
      output.print "│"
      output.print ANSI.move(row, @list_width)
      output.print "│"
    end

    output.print ANSI.move(1, 1)
    output.print "┌" + ("─" * (@list_width - 2)) + "┐"

    output.print ANSI.move(@terminal_height, 1)
    output.print "└" + ("─" * (@list_width - 2)) + "┘"

    output.print ANSI.move(1, 3)
    output.print ANSI.color(" Agents (#{@agents.size}) ", ANSI::CYAN + ANSI::BOLD)

    output.print ANSI.move(@terminal_height, 3)
    if @input_mode
      output.print ANSI.color("ESC:exit input mode", ANSI::YELLOW)
    else
      output.print ANSI.color("j/k:nav i:input K:kill q:quit h:help", ANSI::DIM)
    end

    @agents.each_with_index do |agent, idx|
      row = idx + 2
      break if row >= @terminal_height

      output.print ANSI.move(row, 2)

      status_color = case agent.status
                     when 'running' then ANSI::GREEN
                     when 'initializing', 'spawning' then ANSI::YELLOW
                     else ANSI::RED
                     end

      line = format(
        "[%02d] %s#%s %s",
        agent.id,
        agent.repo.split('/').last[0..10],
        agent.issue_number,
        format_age(agent.age)
      )

      max_width = @list_width - 3
      line = line[0...max_width] if line.length > max_width

      if idx == @selected_index
        output.print ANSI::BOLD + "\e[7m" + line.ljust(max_width) + ANSI::RESET
      else
        output.print ANSI.color(line, status_color)
      end
    end
  end

  def draw_log_view(output)
    log_start_col = @list_width + 1
    log_width = @terminal_width - @list_width

    (1..@terminal_height).each do |row|
      output.print ANSI.move(row, @terminal_width)
      output.print "│"
    end

    output.print ANSI.move(1, log_start_col)
    output.print "┌" + ("─" * (log_width - 2)) + "┐"

    output.print ANSI.move(@terminal_height, log_start_col)
    output.print "└" + ("─" * (log_width - 2)) + "┘"

    selected = selected_agent

    if selected
      output.print ANSI.move(1, log_start_col + 2)
      title = " #{selected.repo}##{selected.issue_number} "
      title = title[0...log_width - 4] if title.length > log_width - 4
      output.print ANSI.color(title, ANSI::CYAN + ANSI::BOLD)

      buffer = selected.buffer
      visible_lines = @terminal_height - 2

      # Calculate max scroll and clamp current position
      max_scroll = [buffer.size - visible_lines, 0].max
      @log_scroll = [@log_scroll, max_scroll].min
      @log_scroll = [@log_scroll, 0].max

      start_line = @log_scroll
      lines_to_show = buffer[start_line, visible_lines] || []

      lines_to_show.each_with_index do |line, idx|
        row = idx + 2
        break if row >= @terminal_height

        output.print ANSI.move(row, log_start_col + 1)
        display_line = line[0...log_width - 2] || ""
        output.print display_line
      end

      if @input_mode
        output.print ANSI.move(@terminal_height, log_start_col + 2)
        prompt = "> " + @input_buffer[0...@input_cursor_pos] + "_" + @input_buffer[@input_cursor_pos..]
        max_input_width = log_width - 4
        display_input = prompt[0...max_input_width] || ""
        output.print ANSI.color(display_input, ANSI::YELLOW + ANSI::BOLD)
      else
        if buffer.size > visible_lines
          output.print ANSI.move(@terminal_height, @terminal_width - 35)
          scroll_pct = max_scroll > 0 ? ((start_line.to_f / max_scroll) * 100).to_i : 100
          end_line = [start_line + visible_lines, buffer.size].min
          output.print ANSI.color("#{scroll_pct}% [#{start_line+1}-#{end_line}/#{buffer.size}] u/d", ANSI::DIM)
        else
          output.print ANSI.move(@terminal_height, @terminal_width - 20)
          output.print ANSI.color("(all content shown)", ANSI::DIM)
        end
      end
    else
      msg = "No agents running"
      output.print ANSI.move(@terminal_height / 2, log_start_col + (log_width - msg.length) / 2)
      output.print ANSI.color(msg, ANSI::DIM)
    end
  end

  def selected_agent
    @mutex.synchronize do
      _selected_agent_unsafe
    end
  end

  def kill_selected_agent
    agent = selected_agent
    return unless agent

    @mutex.synchronize do
      agent.kill
      cleanup_session(agent)
    end
  end

  private

  # Internal helper - only call when mutex is already held!
  def _selected_agent_unsafe
    return nil if @agents.empty?
    @selected_index = [@selected_index, @agents.size - 1].min
    @agents[@selected_index]
  end

  public

  def format_age(seconds)
    if seconds < 60
      "#{seconds.to_i}s"
    elsif seconds < 3600
      "#{(seconds / 60).to_i}m"
    else
      "#{(seconds / 3600).to_i}h"
    end
  end

  def poll_and_spawn
    response = poll_messages
    return unless response && response[:count] > 0

    log "Received #{response[:count]} new message(s)"

    messages = response[:messages] || []

    @mutex.synchronize do
      messages.each do |message|
        process_message(message)
      end
    end
  end

  def process_message(message)
    message_id = message[:id]
    event_type = message[:event_type]

    unless event_type == 'github_mention'
      log "Ignoring message type: #{event_type}"
      ack_message(message_id)
      return
    end

    payload = message[:payload]
    repo = payload[:repo]
    issue_number = payload[:issue_number]

    session_key = repo.gsub('/', '-') + "-#{issue_number}"

    if @agents.any? { |a| a.session_key == session_key }
      log "Agent already running for #{session_key}"
      ack_message(message_id)
      return
    end

    max_sessions = @config[:max_sessions] || 20
    if @agents.size >= max_sessions
      log "Max sessions (#{max_sessions}) reached"
      return
    end

    log "Processing GitHub mention in #{repo}##{issue_number}"

    worktree_path = create_worktree(repo, issue_number)
    unless worktree_path
      log "Failed to create worktree for #{session_key}"
      return
    end

    agent = Agent.new(@next_id, repo, issue_number, worktree_path, @config[:preserve_agent_ansi])
    @next_id += 1

    command = build_agent_command(worktree_path)
    context = payload[:context] || ''

    if agent.spawn_agent(command, context)
      @agents << agent
      log "Agent #{agent.id} spawned for #{repo}##{issue_number}"
      ack_message(message_id)
      save_sessions
    else
      log "Failed to spawn agent for #{session_key}"
      cleanup_worktree(worktree_path)
    end
  end

  def cleanup_agents
    timeout = @config[:agent_timeout] || 3600

    @agents.reject! do |agent|
      should_remove = !agent.alive? || agent.age > timeout || agent.status == 'finished'
      if should_remove
        cleanup_session(agent)
        true
      else
        false
      end
    end

    save_sessions
  end

  def cleanup_session(agent)
    log "Cleaning up agent #{agent.id}: #{agent.repo}##{agent.issue_number}"
    agent.close
    cleanup_worktree(agent.worktree_path)
  end

  def create_worktree(repo, issue_number)
    repo_safe = repo.gsub('/', '-')
    branch_name = "botster-#{repo_safe}-#{issue_number}"
    worktree_base = @config[:worktree_base]
    clone_dir = File.join(worktree_base, repo_safe)
    worktree_path = File.join(worktree_base, "#{repo_safe}-#{issue_number}")

    FileUtils.mkdir_p(worktree_base)

    unless Dir.exist?(clone_dir)
      log "Cloning #{repo}..."
      system("git clone https://github.com/#{repo}.git #{Shellwords.escape(clone_dir)} >> #{Shellwords.escape(LOG_FILE)} 2>&1")
      return nil unless $?.success?
    end

    if Dir.exist?(worktree_path)
      Dir.chdir(clone_dir) do
        system("git worktree remove #{Shellwords.escape(worktree_path)} --force >> #{Shellwords.escape(LOG_FILE)} 2>&1")
      end
      FileUtils.rm_rf(worktree_path) if Dir.exist?(worktree_path)
    end

    Dir.chdir(clone_dir) do
      branch_exists = system("git show-ref --verify --quiet refs/heads/#{Shellwords.escape(branch_name)}")
      cmd = branch_exists ? "git worktree add #{Shellwords.escape(worktree_path)} #{Shellwords.escape(branch_name)}" :
                            "git worktree add -b #{Shellwords.escape(branch_name)} #{Shellwords.escape(worktree_path)}"
      system("#{cmd} >> #{Shellwords.escape(LOG_FILE)} 2>&1")
      return nil unless $?.success?
    end

    claude_dir = File.join(worktree_path, '.claude')
    FileUtils.mkdir_p(claude_dir)
    FileUtils.touch(File.join(claude_dir, 'trusted'))

    worktree_path
  end

  def cleanup_worktree(worktree_path)
    return unless worktree_path && Dir.exist?(worktree_path)
    system("git worktree remove #{Shellwords.escape(worktree_path)} --force >> #{Shellwords.escape(LOG_FILE)} 2>&1")
  end

  def build_agent_command(worktree_path)
    agent_cmd = @config[:agent_command] || 'claude'
    options = []
    if agent_cmd == 'claude'
      options << "--permission-mode #{@config[:claude_permission_mode]}" if @config[:claude_permission_mode]
      options << "--allowedTools #{@config[:claude_allowed_tools]}" if @config[:claude_allowed_tools]
      options << "--add-dir #{Shellwords.escape(worktree_path)}"
    end
    "#{agent_cmd} #{options.join(' ')}"
  end

  def poll_messages
    server_url = @config[:server_url]
    api_key = @config[:api_key]
    return nil if api_key.empty?

    repo_name = detect_repo_name
    url = "#{server_url}/bots/messages"
    url += "?repo=#{URI.encode_www_form_component(repo_name)}" if repo_name

    uri = URI(url)

    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = (uri.scheme == 'https')
      http.open_timeout = 5
      http.read_timeout = 10

      request = Net::HTTP::Get.new(uri.request_uri)
      request['X-API-Key'] = api_key

      response = http.request(request)
      response.code == '200' ? JSON.parse(response.body, symbolize_names: true) : nil
    rescue StandardError => e
      log "Poll error: #{e.message}"
      nil
    end
  end

  def ack_message(message_id)
    server_url = @config[:server_url]
    api_key = @config[:api_key]

    uri = URI("#{server_url}/bots/messages/#{message_id}")

    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = (uri.scheme == 'https')

      request = Net::HTTP::Patch.new(uri.request_uri)
      request['X-API-Key'] = api_key
      request['Content-Type'] = 'application/json'

      http.request(request)
    rescue StandardError => e
      log "Ack error: #{e.message}"
    end
  end

  def detect_repo_name
    `git remote get-url origin 2>/dev/null`.strip.gsub(%r{^(https?://[^/]+/|git@[^:]+:)}, '').gsub(/\.git$/, '')
  rescue
    nil
  end

  def save_sessions
    sessions = @agents.map(&:to_h)
    File.write(SESSIONS_FILE, JSON.pretty_generate(sessions))
  rescue StandardError => e
    log "Failed to save sessions: #{e.message}"
  end

  def running?
    return false unless File.exist?(PID_FILE)
    pid = File.read(PID_FILE).strip.to_i
    Process.kill(0, pid)
    true
  rescue Errno::ESRCH, Errno::ENOENT
    File.delete(PID_FILE) if File.exist?(PID_FILE)
    false
  end

  def cleanup_all_agents
    @poll_thread&.kill
    @agents.each do |agent|
      agent.kill
      cleanup_worktree(agent.worktree_path)
    end
    @agents.clear
  end

  # CLI Commands (unchanged for brevity)
  def cmd_status
    unless running?
      puts "Botster Hub is not running"
      exit 1
    end

    unless File.exist?(SESSIONS_FILE)
      puts "No active sessions"
      exit 0
    end

    sessions = JSON.parse(File.read(SESSIONS_FILE), symbolize_names: true)

    puts "Active Sessions (#{sessions.size}):"
    puts "=" * 80

    sessions.each do |session|
      puts "✓ Agent #{session[:id]}: #{session[:repo]}##{session[:issue_number]}"
      puts "  Path: #{session[:worktree_path]}"
      puts "  Status: #{session[:status]}"
      puts "  Started: #{session[:start_time]}"
      puts
    end
  end

  def cmd_kill(_session_id)
    puts "To kill an agent, use the interactive UI (K key) or restart the daemon"
  end

  def cmd_cleanup
    worktree_base = @config[:worktree_base]
    return unless Dir.exist?(worktree_base)

    puts "Cleaning up stale worktrees..."
    Dir.glob(File.join(worktree_base, '*')).each do |path|
      next unless Dir.exist?(path)
      puts "  Found: #{path}"
    end
  end

  def cmd_config(key = nil, value = nil)
    if key.nil?
      puts "Configuration (#{CONFIG_FILE}):"
      puts JSON.pretty_generate(@config)
      return
    end

    if value.nil?
      puts @config[key.to_sym]
      return
    end

    @config[key.to_sym] = value
    save_config
    puts "Config updated: #{key} = #{value}"
  end

  def cmd_help
    puts <<~HELP
      Botster Hub v#{VERSION} - Interactive PTY-based GitHub automation

      Usage:
        botster_hub start [--headless]  Start the daemon
        botster_hub status              Show active sessions
        botster_hub kill <id>           Kill a specific agent
        botster_hub cleanup             Clean up stale worktrees
        botster_hub config [key] [val]  Show or set configuration
        botster_hub version             Show version

      Interactive Mode:
        j/k or arrows - Navigate agents
        u/d - Scroll log (1 line)
        PgUp/PgDn - Scroll log (10 lines)
        i - Enter input mode (arrows for cursor/history, Enter to send)
        K - Kill selected agent
        h - Help
        q - Quit

      Configuration:
        ... (same as before)
        preserve_agent_ansi     - Keep agent's ANSI codes (default: false - risky!)

      ZERO DEPENDENCIES!
    HELP
  end
end

if __FILE__ == $PROGRAM_NAME
  hub = BotsterHub.new
  hub.run(ARGV)
end
