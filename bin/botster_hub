#!/bin/bash
# Botster Hub - Pure bash daemon for GitHub mention → local agent automation
# ZERO dependencies - uses only macOS built-in tools (curl, grep, sed, osascript)

set -euo pipefail

VERSION="0.1.0"
CONFIG_DIR="$HOME/.botster_hub"
SESSIONS_DIR="$CONFIG_DIR/sessions"
CONFIG_FILE="$CONFIG_DIR/config"
LOG_FILE="$CONFIG_DIR/botster_hub.log"
PID_FILE="$CONFIG_DIR/botster_hub.pid"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

#############################################################################
# Config Management (Simple Key-Value)
#############################################################################

# Get config value
get_config() {
    local key="$1"
    local default="${2:-}"

    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "$default"
        return
    fi

    # Read value from key=value format
    local value=$(grep "^${key}=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2-)
    echo "${value:-$default}"
}

# Set config value
set_config() {
    local key="$1"
    local value="$2"

    if [[ ! -f "$CONFIG_FILE" ]]; then
        touch "$CONFIG_FILE"
    fi

    # Remove existing key if present
    if grep -q "^${key}=" "$CONFIG_FILE" 2>/dev/null; then
        # macOS sed requires backup extension
        sed -i '' "/^${key}=/d" "$CONFIG_FILE"
    fi

    # Add new value
    echo "${key}=${value}" >> "$CONFIG_FILE"

    log "Config updated: $key = $value"
}

#############################################################################
# Session Management (One File Per Session)
#############################################################################

# Get session file path
session_file() {
    local session_key="$1"
    echo "$SESSIONS_DIR/$session_key"
}

# Check if session exists
session_exists() {
    local session_key="$1"
    [[ -f "$(session_file "$session_key")" ]]
}

# Check if session is stale (completed or missing worktree)
is_session_stale() {
    local session_key="$1"

    # If session file doesn't exist, it's not stale (it doesn't exist)
    if ! session_exists "$session_key"; then
        return 1
    fi

    local worktree_path=$(get_session_field "$session_key" "worktree_path")

    # If worktree is missing, session is stale
    if [[ ! -d "$worktree_path" ]]; then
        log "Session ${session_key} is stale: worktree missing at ${worktree_path}" >&2
        return 0
    fi

    # Check for completion marker (use hardcoded default to avoid config dependency)
    local completion_marker=".botster_status"
    local marker_file="${worktree_path}/${completion_marker}"

    if [[ -f "$marker_file" ]]; then
        local content=$(cat "$marker_file" 2>/dev/null)
        if [[ "$content" == *"RESOLVED"* ]] || [[ "$content" == *"DONE"* ]]; then
            log "Session ${session_key} is stale: completion marker found" >&2
            return 0
        fi
    fi

    # Session exists and is not completed
    return 1
}

# Get session field
get_session_field() {
    local session_key="$1"
    local field="$2"
    local default="${3:-}"

    local file=$(session_file "$session_key")

    if [[ ! -f "$file" ]]; then
        echo "$default"
        return
    fi

    local value=$(grep "^${field}=" "$file" 2>/dev/null | cut -d'=' -f2-)
    echo "${value:-$default}"
}

# Create session
create_session() {
    local session_key="$1"
    local message_id="$2"
    local repo="$3"
    local issue_number="$4"
    local worktree_path="$5"
    local terminal_id="$6"

    local file=$(session_file "$session_key")

    cat > "$file" <<EOF
message_id=$message_id
repo=$repo
issue_number=$issue_number
worktree_path=$worktree_path
terminal_id=$terminal_id
started_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)
status=active
EOF
}

# Remove session
remove_session() {
    local session_key="$1"
    local file=$(session_file "$session_key")

    if [[ -f "$file" ]]; then
        rm -f "$file"
    fi
}

# List all session keys
list_sessions() {
    if [[ ! -d "$SESSIONS_DIR" ]]; then
        return
    fi

    for file in "$SESSIONS_DIR"/*; do
        if [[ -f "$file" ]]; then
            basename "$file"
        fi
    done
}

# Count sessions
count_sessions() {
    list_sessions | wc -l | tr -d ' '
}

#############################################################################
# Logging
#############################################################################

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

log_error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*${NC}" | tee -a "$LOG_FILE"
}

log_success() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] $*${NC}" | tee -a "$LOG_FILE"
}

log_warn() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] WARN: $*${NC}" | tee -a "$LOG_FILE"
}

#############################################################################
# Initialization
#############################################################################

init_dirs() {
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$SESSIONS_DIR"
    mkdir -p "$HOME/botster-sessions"

    # Create default config if it doesn't exist
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" <<EOF
server_url=http://localhost:3000
api_key=
agent_command=claude
completion_marker=.botster_status
max_sessions=20
poll_interval=5
worktree_base=$HOME/botster-sessions
claude_permission_mode=acceptEdits
claude_dangerously_skip_permissions=false
claude_allowed_tools=mcp__*
EOF
        log "Created default config at $CONFIG_FILE"
    fi
}

#############################################################################
# Daemon Control
#############################################################################

is_running() {
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if ps -p "$pid" > /dev/null 2>&1; then
            return 0
        else
            rm -f "$PID_FILE"
            return 1
        fi
    fi
    return 1
}

#############################################################################
# Simple JSON Extraction (for API responses only)
#############################################################################

# Extract string value from JSON response
json_extract_string() {
    local json="$1"
    local key="$2"
    echo "$json" | grep -o "\"$key\":\"[^\"]*\"" | head -1 | sed 's/.*:"\(.*\)".*/\1/'
}

# Extract number from JSON response
json_extract_number() {
    local json="$1"
    local key="$2"
    echo "$json" | grep -o "\"$key\":[0-9]*" | head -1 | sed 's/.*:\([0-9]*\).*/\1/'
}

# Extract messages array and process each
process_json_messages() {
    local json="$1"

    # Split messages by },{
    echo "$json" | sed -n 's/.*"messages":\[\(.*\)\].*/\1/p' | sed 's/},{/}|{/g' | tr '|' '\n'
}

# Extract payload object from message
json_extract_payload() {
    local message="$1"
    echo "$message" | sed -n 's/.*"payload":\({[^}]*}\).*/\1/p'
}

#############################################################################
# API Communication
#############################################################################

poll_messages() {
    local server_url=$(get_config "server_url")
    local api_key=$(get_config "api_key")

    if [[ -z "$api_key" ]]; then
        log_error "API key not configured. Run: botster_hub config api_key YOUR_KEY"
        return 1
    fi

    # Get the current git repository name (owner/repo format)
    local repo_name=""
    if git rev-parse --git-dir > /dev/null 2>&1; then
        # Try to get from remote URL
        local remote_url=$(git remote get-url origin 2>/dev/null)
        if [[ -n "$remote_url" ]]; then
            # Extract owner/repo from various Git URL formats
            # SSH: git@github.com:owner/repo.git
            # HTTPS: https://github.com/owner/repo.git
            repo_name=$(echo "$remote_url" | sed -E 's#^(https?://[^/]+/|git@[^:]+:)##' | sed 's/\.git$//')
        fi
    fi

    # Include repo parameter if detected
    local url="$server_url/bots/messages"
    if [[ -n "$repo_name" ]]; then
        url="${url}?repo=${repo_name}"
    fi

    curl -s -H "X-API-Key: $api_key" "$url" 2>/dev/null
}

ack_message() {
    local message_id="$1"
    local server_url=$(get_config "server_url")
    local api_key=$(get_config "api_key")

    curl -s -X PATCH \
        -H "X-API-Key: $api_key" \
        -H "Content-Type: application/json" \
        "$server_url/bots/messages/$message_id" \
        > /dev/null 2>&1

    if [[ $? -eq 0 ]]; then
        log "Acknowledged message: $message_id"
    else
        log_error "Failed to acknowledge message: $message_id"
    fi
}

#############################################################################
# Git Worktree Management
#############################################################################

create_worktree() {
    local repo="$1"
    local issue_number="$2"

    # Sanitize repo name for filesystem
    local repo_safe="${repo//\//-}"
    local branch_name="botster-${repo_safe}-${issue_number}"
    local worktree_base=$(get_config "worktree_base")
    local clone_dir="$worktree_base/$repo_safe"
    local worktree_path="$worktree_base/${repo_safe}-${issue_number}"

    # Clone the repo if it doesn't exist
    if [[ ! -d "$clone_dir" ]]; then
        log "Cloning repository: https://github.com/$repo.git to $clone_dir" >&2
        if ! git clone "https://github.com/$repo.git" "$clone_dir" >> "$LOG_FILE" 2>&1; then
            log_error "Failed to clone repository: $repo" >&2
            return 1
        fi
    else
        log "Using existing clone: $clone_dir" >&2
        pushd "$clone_dir" > /dev/null
        git pull >> "$LOG_FILE" 2>&1 || log_warn "Failed to pull latest changes" >&2
        popd > /dev/null
    fi

    # === CRITICAL: Use absolute path for worktree add ===
    # git worktree add creates the directory relative to the current repo
    # We must cd into the clone first, then use absolute path for the target
    pushd "$clone_dir" > /dev/null

    if [[ -d "$worktree_path" ]]; then
        log "Reusing existing worktree: $worktree_path" >&2
    else
        if git show-ref --verify --quiet "refs/heads/$branch_name"; then
            log "Creating worktree from existing branch: $branch_name" >&2
            git worktree add "$worktree_path" "$branch_name" >> "$LOG_FILE" 2>&1 || { popd > /dev/null; return 1; }
        else
            log "Creating worktree with new branch: $branch_name" >&2
            git worktree add -b "$branch_name" "$worktree_path" >> "$LOG_FILE" 2>&1 || { popd > /dev/null; return 1; }
        fi
        log_success "Created worktree: $worktree_path" >&2
    fi

    popd > /dev/null

    # Pre-trust the directory
    mkdir -p "$worktree_path/.claude"
    touch "$worktree_path/.claude/trusted"
    log "Pre-trusted worktree: $worktree_path" >&2

    # Output ONLY the path to stdout (everything else goes to stderr)
    echo "$worktree_path"
}

#############################################################################
# Agent CLI Options Management
#############################################################################

# Build CLI options for Claude Code
build_claude_code_options() {
    local options=""

    # Whitelisted Claude Code options
    local model=$(get_config "claude_model")
    local permission_mode=$(get_config "claude_permission_mode")
    local max_turns=$(get_config "claude_max_turns")
    local add_dir=$(get_config "claude_add_dir")
    local system_prompt=$(get_config "claude_system_prompt")
    local system_prompt_file=$(get_config "claude_system_prompt_file")
    local append_system_prompt=$(get_config "claude_append_system_prompt")
    local allowed_tools=$(get_config "claude_allowed_tools")
    local disallowed_tools=$(get_config "claude_disallowed_tools")
    local verbose=$(get_config "claude_verbose")
    local dangerously_skip_permissions=$(get_config "claude_dangerously_skip_permissions")
    local mcp_config=$(get_config "claude_mcp_config")
    local settings=$(get_config "claude_settings")

    # Build options string (only include non-empty values)
    if [[ -n "$model" ]]; then
        options="$options --model $model"
    fi

    if [[ -n "$permission_mode" ]]; then
        options="$options --permission-mode $permission_mode"
    fi

    if [[ -n "$max_turns" ]]; then
        options="$options --max-turns $max_turns"
    fi

    if [[ -n "$add_dir" ]]; then
        options="$options --add-dir $add_dir"
    fi

    if [[ -n "$system_prompt" ]]; then
        options="$options --system-prompt '$system_prompt'"
    fi

    if [[ -n "$system_prompt_file" ]]; then
        options="$options --system-prompt-file $system_prompt_file"
    fi

    if [[ -n "$append_system_prompt" ]]; then
        options="$options --append-system-prompt '$append_system_prompt'"
    fi

    if [[ -n "$allowed_tools" ]]; then
        options="$options --allowedTools $allowed_tools"
    fi

    if [[ -n "$disallowed_tools" ]]; then
        options="$options --disallowedTools $disallowed_tools"
    fi

    if [[ "$verbose" == "true" ]]; then
        options="$options --verbose"
    fi

    if [[ "$dangerously_skip_permissions" == "true" ]]; then
        options="$options --dangerously-skip-permissions"
    fi

    if [[ -n "$mcp_config" ]]; then
        options="$options --mcp-config $mcp_config"
    fi

    if [[ -n "$settings" ]]; then
        options="$options --settings $settings"
    fi

    # Trim leading space and return
    echo "${options# }"
}

# Build CLI options based on agent command
build_agent_options() {
    local agent_command=$(get_config "agent_command")

    case "$agent_command" in
        claude|"claude code")
            build_claude_code_options
            ;;
        *)
            # No special options for other agents
            echo ""
            ;;
    esac
}

#############################################################################
# Terminal Session Management
#############################################################################

spawn_terminal() {
    local worktree_path="$1"
    local repo="$2"
    local issue_number="$3"
    local context="$4"

    local agent_command=$(get_config "agent_command")
    local agent_options=$(build_agent_options)
    local completion_marker=$(get_config "completion_marker")
    local api_key=$(get_config "api_key")

    # Get the main project directory (where the daemon is running from)
    local main_project_dir="$(pwd)"

    # Create temporary files for script and context
    local script_file=$(mktemp)
    local context_file=$(mktemp)

    # Write context to file using printf to preserve exact content
    printf '%s' "$context" > "$context_file"

    # Write the shell script that will be executed in the terminal
    # Register MCP server at local scope (project-specific user settings)
    # This avoids needing approval for project-scoped .mcp.json
    cat > "$script_file" <<SCRIPT_EOF
#!/bin/bash
cd '$worktree_path' || { echo "FATAL: Cannot cd to worktree: $worktree_path"; exit 1; }

# Create .claude directory and mark as trusted
mkdir -p .claude
touch .claude/trusted

export BOTSTER_API_KEY='$api_key'

# Register trybotster MCP server at local scope (highest precedence, no approval needed)
echo "Registering trybotster MCP server..."
claude mcp add trybotster \\
  --transport http \\
  https://mcp-dev.trybotster.com \\
  --header "Authorization: Bearer $api_key" \\
  || echo "WARNING: Failed to register MCP server"

# Verify server is available
echo "Verifying MCP server..."
claude mcp list

# Copy .claude settings from main project
echo "Setting up .claude permissions..."
mkdir -p .claude/hooks

# Copy settings.local.json from main project if it exists
if [ -f "$main_project_dir/.claude/settings.local.json" ]; then
  cp "$main_project_dir/.claude/settings.local.json" .claude/settings.local.json
  echo "✓ Copied settings.local.json from main project"
else
  echo "⚠ No settings.local.json found in main project at:"
  echo "  $main_project_dir/.claude/settings.local.json"
  echo "  Spawned Claude will use default permissions"
fi

# Create auto-exit hook script
echo "Creating auto-exit hook for completion detection..."
cat > .claude/hooks/check_completion.sh <<HOOK_EOF
#!/bin/bash
# Auto-exit hook - checks for completion marker and exits session

COMPLETION_MARKER="$completion_marker"

# Check if completion marker exists
if [ -f "\\\$COMPLETION_MARKER" ]; then
  content=\\\$(cat "\\\$COMPLETION_MARKER" 2>/dev/null)

  # Check if Claude marked task as complete
  if [[ "\\\$content" == *"RESOLVED"* ]] || [[ "\\\$content" == *"DONE"* ]]; then
    echo ""
    echo "✓ Task marked as complete. Exiting Claude Code session..."
    echo ""

    # Exit the Claude Code session
    exit 0
  fi
fi
HOOK_EOF

chmod +x .claude/hooks/check_completion.sh

# Create hooks configuration
cat > .claude/hooks.json <<'HOOKS_JSON_EOF'
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/check_completion.sh"
          }
        ]
      }
    ]
  }
}
HOOKS_JSON_EOF

echo "✓ Created auto-exit hook configuration"

# Pre-accept trust dialog for this worktree in ~/.claude.json
echo "Pre-accepting workspace trust..."
node -e "
const fs = require('fs');
const path = require('path');
const configPath = path.join(process.env.HOME, '.claude.json');
try {
  const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
  const projectPath = '$worktree_path';
  if (!config.projects) config.projects = {};
  if (!config.projects[projectPath]) {
    config.projects[projectPath] = {
      allowedTools: [],
      mcpContextUris: [],
      mcpServers: {},
      enabledMcpjsonServers: [],
      disabledMcpjsonServers: [],
      hasTrustDialogAccepted: true,
      projectOnboardingSeenCount: 0,
      hasClaudeMdExternalIncludesApproved: false,
      hasClaudeMdExternalIncludesWarningShown: false
    };
  } else {
    config.projects[projectPath].hasTrustDialogAccepted = true;
  }
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
  console.log('✓ Pre-accepted workspace trust for this worktree');
} catch (e) {
  console.error('Warning: Failed to pre-accept trust:', e.message);
}
"

# Start Claude Code with context
# Use --add-dir to pre-trust this worktree directory
echo "Starting Claude Code..."
$agent_command $agent_options --add-dir '$worktree_path' -- "\$(cat '$context_file')" || echo 'Agent failed'
echo 'DONE' > $completion_marker
rm -f '$context_file' '$script_file'

# Wait a moment for cleanup, then close the terminal
echo ""
echo "Session complete. Terminal will close in 5 seconds..."
sleep 5
osascript -e 'tell application "Terminal" to close (every window whose name contains "Botster:")' 2>/dev/null || true
SCRIPT_EOF

    chmod +x "$script_file"

    # Escape for AppleScript
    local esc_script="${script_file//\'/\'\\\'\'}"
    local esc_title="Botster: ${repo//#/\\#}#${issue_number}"
    esc_title="${esc_title//\'/\'\\\'\'}"

    # AppleScript to spawn Terminal and get window ID by parsing do script output
    local tab_desc
    tab_desc=$(osascript <<EOF 2>&1
tell application "Terminal"
    activate
    do script "$esc_script"
end tell
EOF
)

    if [[ $? -ne 0 ]]; then
        log_error "AppleScript failed: $tab_desc"
        return 1
    fi

    # Parse window ID from tab description, e.g. "tab 1 of window id 12345"
    local terminal_id=$(echo "$tab_desc" | sed -n 's/.*window id \([0-9]*\).*/\1/p')

    # Set title (separate osascript, as it's now open)
    if [[ -n "$terminal_id" ]]; then
        osascript <<EOF 2>/dev/null
tell application "Terminal"
    set custom title of window id $terminal_id to "$esc_title"
end tell
EOF
    fi

    if [[ -n "$terminal_id" && "$terminal_id" =~ ^[0-9]+$ ]]; then
        log_success "Spawned terminal for ${repo}#${issue_number}"
        log "Terminal ID: $terminal_id" >&2
        echo "$terminal_id"
    else
        log_error "Failed to spawn terminal: Invalid ID from $tab_desc"
        return 1
    fi
}

#############################################################################
# Message Processing
#############################################################################

process_messages() {
    local response=$(poll_messages)

    if [[ -z "$response" ]]; then
        return 0
    fi

    # Get count
    local count=$(json_extract_number "$response" "count")

    if [[ -z "$count" ]] || [[ "$count" -eq 0 ]]; then
        return 0
    fi

    log "Received $count new message(s)"

    # Process each message
    process_json_messages "$response" | while IFS= read -r message; do
        if [[ -z "$message" ]]; then
            continue
        fi

        local message_id=$(json_extract_number "$message" "id")
        local event_type=$(json_extract_string "$message" "event_type")

        if [[ "$event_type" != "github_mention" ]]; then
            log_warn "Ignoring message type: $event_type"
            ack_message "$message_id"
            continue
        fi

        # Extract payload
        local payload=$(json_extract_payload "$message")

        local repo=$(json_extract_string "$payload" "repo")
        local issue_number=$(json_extract_number "$payload" "issue_number")
        # Replace slash in repo name with dash for safe filesystem path
        local repo_safe="${repo//\//-}"
        local session_key="${repo_safe}-${issue_number}"

        # Check if session already exists
        if session_exists "$session_key"; then
            # Check if session is stale (completed or missing worktree)
            if is_session_stale "$session_key"; then
                log "Session ${session_key} is stale, cleaning up"

                # Cleanup stale session
                local worktree_path=$(get_session_field "$session_key" "worktree_path")
                if [[ -d "$worktree_path" ]]; then
                    git worktree remove "$worktree_path" --force >> "$LOG_FILE" 2>&1 || true
                fi
                remove_session "$session_key"

                log_success "Cleaned up stale session: ${session_key}"
                # Continue processing this message
            else
                log_warn "Session already exists for ${session_key}, skipping"
                ack_message "$message_id"
                continue
            fi
        fi

        # Check max sessions
        local max_sessions=$(get_config "max_sessions" "20")
        local current_sessions=$(count_sessions)

        if [[ "$current_sessions" -ge "$max_sessions" ]]; then
            log_warn "Max sessions ($max_sessions) reached, skipping"
            continue
        fi

        log "Processing GitHub mention in ${repo}#${issue_number}"

        # Create worktree
        local worktree_path=$(create_worktree "$repo" "$issue_number")

        if [[ $? -ne 0 ]]; then
            log_error "Failed to create worktree for ${session_key}"
            continue
        fi

        # Get context
        local context=$(json_extract_string "$payload" "context")

        # Append trust snippet to context for Claude-Code
        local agent_command=$(get_config "agent_command")
        if [[ "$agent_command" == "claude" || "$agent_command" == "claude code" ]]; then
            context+=$'\n\n**First action (run automatically):**
```bash
# Trust this directory once (creates .claude/trusted if needed)
mkdir -p .claude && touch .claude/trusted
echo "Directory trusted for this session"
```'
        fi

        # Spawn terminal
        local terminal_id
        terminal_id=$(spawn_terminal "$worktree_path" "$repo" "$issue_number" "$context")
        local spawn_status=$?

        if [[ $spawn_status -ne 0 ]]; then
            log_error "Failed to spawn terminal for ${session_key}"
            git worktree remove "$worktree_path" --force 2>/dev/null || true
            continue
        fi

        # Verify terminal_id doesn't contain error messages
        if [[ -z "$terminal_id" ]] || [[ "$terminal_id" == *"error"* ]] || [[ "$terminal_id" == *"syntax error"* ]]; then
            log_error "Invalid terminal ID for ${session_key}: $terminal_id"
            git worktree remove "$worktree_path" --force 2>/dev/null || true
            continue
        fi

        # Create session file
        create_session "$session_key" "$message_id" "$repo" "$issue_number" "$worktree_path" "$terminal_id"

        # Acknowledge message
        ack_message "$message_id"

        log_success "Session created: ${session_key}"
    done
}

#############################################################################
# Session Health Monitoring
#############################################################################

check_sessions() {
    local completion_marker=$(get_config "completion_marker")

    for session_key in $(list_sessions); do
        local worktree_path=$(get_session_field "$session_key" "worktree_path")

        # Check if worktree still exists
        if [[ ! -d "$worktree_path" ]]; then
            log_warn "Worktree missing for ${session_key}, cleaning up"
            remove_session "$session_key"
            continue
        fi

        # Check for completion marker
        local marker_file="${worktree_path}/${completion_marker}"

        if [[ -f "$marker_file" ]]; then
            local content=$(cat "$marker_file")

            if [[ "$content" == *"RESOLVED"* ]] || [[ "$content" == *"DONE"* ]]; then
                log "Session completed: ${session_key}"

                # Cleanup worktree - check if it still exists first
                if [[ -d "$worktree_path" ]]; then
                    # Try to remove the worktree, but don't fail if it errors
                    if git worktree remove "$worktree_path" --force >> "$LOG_FILE" 2>&1; then
                        log "Removed worktree: $worktree_path"
                    else
                        log_warn "Could not remove worktree (may be in use): $worktree_path"
                        # Still clean up the session - worktree will be cleaned up later
                    fi
                fi

                # Remove session file
                remove_session "$session_key"

                log_success "Cleaned up session: ${session_key}"
            fi
        fi
    done
}

#############################################################################
# Commands
#############################################################################

cmd_start() {
    if is_running; then
        echo "Botster Hub is already running (PID: $(cat $PID_FILE))"
        exit 1
    fi

    # Validate that we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not in a git repository. Botster Hub must be run from the root of your project."
        exit 1
    fi

    # Validate that we can detect the repository name
    local remote_url=$(git remote get-url origin 2>/dev/null)
    if [[ -z "$remote_url" ]]; then
        log_error "No git remote 'origin' found. Please configure a remote first:"
        log_error "  git remote add origin <url>"
        exit 1
    fi

    # Extract and validate repo name
    local repo_name=$(echo "$remote_url" | sed -E 's#^(https?://[^/]+/|git@[^:]+:)##' | sed 's/\.git$//')
    if [[ -z "$repo_name" ]] || [[ ! "$repo_name" =~ / ]]; then
        log_error "Could not extract repository name from remote URL: $remote_url"
        log_error "Expected format: owner/repo"
        exit 1
    fi

    log_success "Starting Botster Hub v${VERSION}"
    log "Server: $(get_config server_url)"
    log "Repository: $repo_name"
    log "Poll interval: $(get_config poll_interval)s"

    # Write PID
    echo $$ > "$PID_FILE"

    # Setup signal handlers
    trap 'log "Shutting down..."; rm -f "$PID_FILE"; exit 0' INT TERM

    local poll_interval=$(get_config "poll_interval" "5")

    # Main loop
    while true; do
        process_messages
        check_sessions
        sleep "$poll_interval"
    done
}

# Test command - spawns a test terminal
cmd_test() {
    log "Testing terminal spawn in 3 seconds..."
    sleep 3

    local test_path=$(pwd)
    local test_repo="test/repo"
    local test_issue="999"
    local test_context="This is a test message from botster_hub.

Please confirm that:
1. This terminal opened successfully
2. Claude received this message
3. You can see this context

If you can see this, the terminal spawning is working!"

    log "Spawning test terminal..."
    spawn_terminal "$test_path" "$test_repo" "$test_issue" "$test_context"

    log "Test terminal spawned. Check if new terminal opened."
    log "Daemon will keep running for 30 seconds..."

    # Keep running for 30 seconds to see if terminal stays open
    sleep 30

    log "Test complete."
}

cmd_status() {
    if ! is_running; then
        echo "Botster Hub is not running"
        exit 1
    fi

    local session_count=$(count_sessions)

    if [[ "$session_count" -eq 0 ]]; then
        echo "No active sessions"
        exit 0
    fi

    echo "Active Sessions ($session_count):"
    printf '=%.0s' {1..80}
    echo

    for session_key in $(list_sessions); do
        local repo=$(get_session_field "$session_key" "repo")
        local issue_number=$(get_session_field "$session_key" "issue_number")
        local worktree_path=$(get_session_field "$session_key" "worktree_path")
        local started_at=$(get_session_field "$session_key" "started_at")
        local status=$(get_session_field "$session_key" "status")

        echo "✓ ${session_key}"
        echo "  Repo: ${repo}"
        echo "  Issue: #${issue_number}"
        echo "  Path: ${worktree_path}"
        echo "  Started: ${started_at}"
        echo "  Status: ${status}"
        echo
    done
}

cmd_kill() {
    local session_key="$1"

    if [[ -z "$session_key" ]]; then
        echo "Usage: botster_hub kill <session_key>"
        exit 1
    fi

    if ! session_exists "$session_key"; then
        echo "Session not found: $session_key"
        exit 1
    fi

    local worktree_path=$(get_session_field "$session_key" "worktree_path")

    log "Killing session: $session_key"

    # Remove worktree
    if [[ -d "$worktree_path" ]]; then
        git worktree remove "$worktree_path" --force 2>&1 | tee -a "$LOG_FILE" || true
    fi

    # Remove session file
    remove_session "$session_key"

    log_success "Session killed: $session_key"
}

cmd_cleanup() {
    log "Cleaning up stale sessions..."

    local removed=0

    for session_key in $(list_sessions); do
        local worktree_path=$(get_session_field "$session_key" "worktree_path")

        if [[ ! -d "$worktree_path" ]]; then
            log "Removing stale session: $session_key"
            remove_session "$session_key"
            ((removed++))
        fi
    done

    echo "Cleaned up $removed stale session(s)"
}

cmd_config() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" ]]; then
        # Show all config
        echo "Configuration ($CONFIG_FILE):"
        cat "$CONFIG_FILE"
        exit 0
    fi

    if [[ -z "$value" ]]; then
        # Show specific key
        echo "$(get_config "$key")"
        exit 0
    fi

    # Set value
    set_config "$key" "$value"
}

cmd_help() {
    cat <<EOF
Botster Hub v${VERSION} - GitHub mention → local agent automation

Usage:
  botster_hub start                  Start the daemon
  botster_hub test                   Test terminal spawning with Claude
  botster_hub status                 Show active sessions
  botster_hub kill <session_key>     Kill a specific session
  botster_hub cleanup                Clean up stale worktrees
  botster_hub config [key] [value]   Show or set configuration
  botster_hub version                Show version

Configuration ($CONFIG_FILE):
  server_url       - Rails server URL (default: http://localhost:3000)
  api_key          - API key for authentication
  agent_command    - Command to run (default: claude)
  completion_marker - File to watch for completion (default: .botster_status)
  max_sessions     - Max concurrent sessions (default: 20)
  poll_interval    - Seconds between polls (default: 5)
  worktree_base    - Base directory for worktrees

Claude Code Agent Options (when agent_command=claude):
  claude_model                        - Model to use (sonnet, opus, etc)
  claude_permission_mode              - Permission mode (acceptEdits, plan, etc)
  claude_max_turns                    - Max agentic turns in non-interactive mode
  claude_add_dir                      - Additional working directories
  claude_system_prompt                - Custom system prompt (replaces default)
  claude_system_prompt_file           - Load system prompt from file
  claude_append_system_prompt         - Append to default system prompt
  claude_allowed_tools                - Tools permitted without prompting
  claude_disallowed_tools             - Tools blocked
  claude_verbose                      - Enable verbose logging (true/false)
  claude_dangerously_skip_permissions - Skip permission prompts (true/false)
  claude_mcp_config                   - Path to MCP config file or JSON string
  claude_settings                     - Path to settings JSON file or JSON string

Example: Configure Claude Code with acceptEdits permissions
  botster_hub config agent_command claude
  botster_hub config claude_permission_mode acceptEdits
  botster_hub config claude_model sonnet

Example: Use your home directory MCP config
  botster_hub config claude_mcp_config ~/.config/claude/mcp_servers.json

Example: Use your home directory settings
  botster_hub config claude_settings ~/.config/claude/settings.json

Session Files:
  Each session stored in: $SESSIONS_DIR/<repo>-<issue>
  Simple key=value format, one session per file

Examples:
  botster_hub config                          # Show all config
  botster_hub config api_key                  # Show API key
  botster_hub config api_key "your_key_here"  # Set API key
  botster_hub config agent_command "aider"    # Change agent
  botster_hub start                           # Start daemon

ZERO DEPENDENCIES - Uses only macOS built-ins!
No jq, no Python, no Ruby - just pure bash!
EOF
}

#############################################################################
# Main
#############################################################################

main() {
    init_dirs

    local command="${1:-}"

    case "$command" in
        start)
            cmd_start
            ;;
        test)
            cmd_test
            ;;
        status)
            cmd_status
            ;;
        kill)
            cmd_kill "${2:-}"
            ;;
        cleanup)
            cmd_cleanup
            ;;
        config)
            cmd_config "${2:-}" "${3:-}"
            ;;
        version|--version|-v)
            echo "Botster Hub v${VERSION}"
            ;;
        help|--help|-h|"")
            cmd_help
            ;;
        *)
            echo "Unknown command: $command"
            echo "Run 'botster_hub help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
