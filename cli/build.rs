//! Build script for botster CLI.
//!
//! Embeds all Lua files from the `lua/` directory into the binary at compile time.
//! This allows the CLI to run without external Lua files in release mode.
//!
//! Generated file: `$OUT_DIR/embedded_lua.rs`
//!
//! The generated module provides:
//! - `EMBEDDED_LUA_FILES`: Array of (path, content) tuples
//! - `get_embedded_lua(path) -> Option<&'static str>`: Lookup function

use std::env;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_lua.rs");
    let profile = env::var("PROFILE").unwrap_or_default();

    if profile == "release" {
        generate_embedded_lua(&dest_path);
    } else {
        generate_stub_lua(&dest_path);
    }
}

/// Generate embedded Lua module with all files inlined via include_str!().
/// Used for release builds so the binary is self-contained.
fn generate_embedded_lua(dest_path: &Path) {
    let lua_dir = Path::new("lua");

    // Collect all Lua files
    let mut lua_files: Vec<(String, String)> = Vec::new();
    if lua_dir.exists() {
        collect_lua_files(lua_dir, lua_dir, &mut lua_files);
    }

    // Sort for deterministic builds
    lua_files.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the Rust source
    let mut output = File::create(dest_path).unwrap();

    writeln!(output, "// Auto-generated by build.rs - do not edit").unwrap();
    writeln!(output, "// Embeds all Lua files from cli/lua/").unwrap();
    writeln!(output).unwrap();

    // Generate the array of embedded files
    writeln!(
        output,
        "pub static EMBEDDED_LUA_FILES: &[(&str, &str)] = &["
    )
    .unwrap();

    for (rel_path, abs_path) in &lua_files {
        // Use include_str! with the absolute path
        writeln!(
            output,
            "    (\"{}\", include_str!(\"{}\")),",
            rel_path, abs_path
        )
        .unwrap();
    }

    writeln!(output, "];").unwrap();
    writeln!(output).unwrap();

    // Generate the lookup function
    writeln!(output, "/// Get embedded Lua file content by relative path.").unwrap();
    writeln!(output, "///").unwrap();
    writeln!(output, "/// # Arguments").unwrap();
    writeln!(output, "///").unwrap();
    writeln!(output, "/// * `path` - Relative path like \"core/init.lua\"").unwrap();
    writeln!(output, "///").unwrap();
    writeln!(output, "/// # Returns").unwrap();
    writeln!(output, "///").unwrap();
    writeln!(output, "/// The file content if found, None otherwise.").unwrap();
    writeln!(output, "#[allow(dead_code)]").unwrap();
    writeln!(output, "pub fn get_embedded_lua(path: &str) -> Option<&'static str> {{").unwrap();
    writeln!(output, "    EMBEDDED_LUA_FILES").unwrap();
    writeln!(output, "        .iter()").unwrap();
    writeln!(output, "        .find(|(p, _)| *p == path)").unwrap();
    writeln!(output, "        .map(|(_, content)| *content)").unwrap();
    writeln!(output, "}}").unwrap();

    // Tell Cargo to rerun if any Lua file changes.
    //
    // cargo:rerun-if-changed on a directory only watches the directory's own
    // mtime, NOT files in subdirectories. We must watch each subdirectory
    // individually so that adding a new .lua file (which changes the parent
    // dir's mtime) triggers a rebuild.
    watch_lua_directory(&Path::new("lua"));

    // Also watch individual files for content changes
    for (_, abs_path) in &lua_files {
        println!("cargo:rerun-if-changed={}", abs_path);
    }
}

/// Generate stub embedded Lua module with empty array.
/// Used for debug builds — Lua files are loaded from the filesystem and
/// hot-reloaded, so embedding them would just cause unnecessary recompiles.
fn generate_stub_lua(dest_path: &Path) {
    let mut output = File::create(dest_path).unwrap();

    writeln!(output, "// Auto-generated by build.rs - do not edit").unwrap();
    writeln!(output, "// Debug build: Lua files loaded from filesystem, not embedded").unwrap();
    writeln!(output).unwrap();
    writeln!(
        output,
        "pub static EMBEDDED_LUA_FILES: &[(&str, &str)] = &[];"
    )
    .unwrap();
    writeln!(output).unwrap();
    writeln!(output, "#[allow(dead_code)]").unwrap();
    writeln!(output, "pub fn get_embedded_lua(_path: &str) -> Option<&'static str> {{").unwrap();
    writeln!(output, "    None").unwrap();
    writeln!(output, "}}").unwrap();

    // Only rerun if build.rs itself changes, NOT when Lua files change
    println!("cargo:rerun-if-changed=build.rs");
}

/// Recursively register `cargo:rerun-if-changed` for a directory and all
/// its subdirectories.
///
/// `cargo:rerun-if-changed` on a directory only detects changes to the
/// directory's own mtime (e.g., a file added/removed directly inside it).
/// Without watching subdirectories, adding `lua/lib/agent.lua` would only
/// change `lua/lib/`'s mtime — not `lua/`'s — so build.rs wouldn't re-run
/// and the new file would be missing from the embedded binary.
fn watch_lua_directory(dir: &Path) {
    println!("cargo:rerun-if-changed={}", dir.display());
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            if entry.path().is_dir() {
                watch_lua_directory(&entry.path());
            }
        }
    }
}

/// Recursively collect all .lua files from a directory.
fn collect_lua_files(base: &Path, dir: &Path, files: &mut Vec<(String, String)>) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                collect_lua_files(base, &path, files);
            } else if path.extension().map_or(false, |ext| ext == "lua") {
                // Get relative path from base
                let rel_path = path
                    .strip_prefix(base)
                    .unwrap()
                    .to_string_lossy()
                    .to_string();
                // Get absolute path for include_str!
                let abs_path = path.canonicalize().unwrap().to_string_lossy().to_string();
                files.push((rel_path, abs_path));
            }
        }
    }
}
