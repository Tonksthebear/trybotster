// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerCertificate {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub certificate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `ServerCertificate`.
pub mod server_certificate {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Certificate {
        #[prost(uint32, optional, tag = "1")]
        pub id: ::core::option::Option<u32>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SenderCertificate {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub certificate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `SenderCertificate`.
pub mod sender_certificate {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Certificate {
        #[prost(string, optional, tag = "1")]
        pub sender_e164: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "2")]
        pub sender_device: ::core::option::Option<u32>,
        #[prost(fixed64, optional, tag = "3")]
        pub expires: ::core::option::Option<u64>,
        #[prost(bytes = "vec", optional, tag = "4")]
        pub identity_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(oneof = "certificate::SenderUuid", tags = "6, 7")]
        pub sender_uuid: ::core::option::Option<certificate::SenderUuid>,
        #[prost(oneof = "certificate::Signer", tags = "5, 8")]
        pub signer: ::core::option::Option<certificate::Signer>,
    }
    /// Nested message and enum types in `Certificate`.
    pub mod certificate {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum SenderUuid {
            #[prost(string, tag = "6")]
            UuidString(::prost::alloc::string::String),
            #[prost(bytes, tag = "7")]
            UuidBytes(::prost::alloc::vec::Vec<u8>),
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Signer {
            #[prost(bytes, tag = "5")]
            Certificate(::prost::alloc::vec::Vec<u8>),
            #[prost(uint32, tag = "8")]
            Id(u32),
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnidentifiedSenderMessage {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub ephemeral_public: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub encrypted_static: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub encrypted_message: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `UnidentifiedSenderMessage`.
pub mod unidentified_sender_message {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Message {
        #[prost(enumeration = "message::Type", optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub sender_certificate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub content: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(enumeration = "message::ContentHint", optional, tag = "4")]
        pub content_hint: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "5")]
        pub group_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    /// Nested message and enum types in `Message`.
    pub mod message {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            PrekeyMessage = 1,
            Message = 2,
            SenderkeyMessage = 7,
            PlaintextContent = 8,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::PrekeyMessage => "PREKEY_MESSAGE",
                    Self::Message => "MESSAGE",
                    Self::SenderkeyMessage => "SENDERKEY_MESSAGE",
                    Self::PlaintextContent => "PLAINTEXT_CONTENT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PREKEY_MESSAGE" => Some(Self::PrekeyMessage),
                    "MESSAGE" => Some(Self::Message),
                    "SENDERKEY_MESSAGE" => Some(Self::SenderkeyMessage),
                    "PLAINTEXT_CONTENT" => Some(Self::PlaintextContent),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ContentHint {
            /// Sender will try to resend; delay any error UI if possible
            Resendable = 1,
            /// Don't show any error UI at all; this is something sent implicitly like a typing message or a receipt
            Implicit = 2,
        }
        impl ContentHint {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Resendable => "RESENDABLE",
                    Self::Implicit => "IMPLICIT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RESENDABLE" => Some(Self::Resendable),
                    "IMPLICIT" => Some(Self::Implicit),
                    _ => None,
                }
            }
        }
    }
}
