// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PolynomialEncoder {
    #[prost(uint32, tag = "1")]
    pub idx: u32,
    /// We'd like to use a oneof here, but proto3 doesn't allow
    /// a combination of `oneof` and `repeated`.  So, we just
    /// only set one of these values to non-empty:
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub pts: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub polys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PolynomialDecoder {
    #[prost(uint32, tag = "1")]
    pub pts_needed: u32,
    #[prost(uint32, tag = "2")]
    pub polys: u32,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub pts: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, tag = "4")]
    pub is_complete: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PqRatchetState {
    #[prost(message, optional, tag = "1")]
    pub version_negotiation: ::core::option::Option<
        pq_ratchet_state::VersionNegotiation,
    >,
    #[prost(message, optional, tag = "2")]
    pub chain: ::core::option::Option<Chain>,
    #[prost(oneof = "pq_ratchet_state::Inner", tags = "3")]
    pub inner: ::core::option::Option<pq_ratchet_state::Inner>,
}
/// Nested message and enum types in `PqRatchetState`.
pub mod pq_ratchet_state {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct VersionNegotiation {
        #[prost(bytes = "vec", tag = "1")]
        pub auth_key: ::prost::alloc::vec::Vec<u8>,
        #[prost(enumeration = "super::Direction", tag = "2")]
        pub direction: i32,
        #[prost(enumeration = "super::Version", tag = "3")]
        pub min_version: i32,
        #[prost(message, optional, tag = "4")]
        pub chain_params: ::core::option::Option<super::ChainParams>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Inner {
        #[prost(message, tag = "3")]
        V1(super::V1State),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Chunk {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct V1Msg {
    #[prost(uint64, tag = "1")]
    pub epoch: u64,
    #[prost(uint32, tag = "2")]
    pub index: u32,
    #[prost(oneof = "v1_msg::InnerMsg", tags = "3, 4, 5, 6, 7, 8")]
    pub inner_msg: ::core::option::Option<v1_msg::InnerMsg>,
}
/// Nested message and enum types in `V1Msg`.
pub mod v1_msg {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum InnerMsg {
        /// send_ek
        #[prost(message, tag = "3")]
        Hdr(super::Chunk),
        #[prost(message, tag = "4")]
        Ek(super::Chunk),
        #[prost(message, tag = "5")]
        EkCt1Ack(super::Chunk),
        #[prost(bool, tag = "6")]
        Ct1Ack(bool),
        /// send_ct
        #[prost(message, tag = "7")]
        Ct1(super::Chunk),
        #[prost(message, tag = "8")]
        Ct2(super::Chunk),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Authenticator {
    #[prost(bytes = "vec", tag = "1")]
    pub root_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub mac_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct V1State {
    #[prost(oneof = "v1_state::InnerState", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
    pub inner_state: ::core::option::Option<v1_state::InnerState>,
}
/// Nested message and enum types in `V1State`.
pub mod v1_state {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Unchunked {}
    /// Nested message and enum types in `Unchunked`.
    pub mod unchunked {
        /// // send_ek ////
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct KeysUnsampled {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HeaderSent {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub ek: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "4")]
            pub dk: ::prost::alloc::vec::Vec<u8>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EkSent {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub dk: ::prost::alloc::vec::Vec<u8>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EkSentCt1Received {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub dk: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "4")]
            pub ct1: ::prost::alloc::vec::Vec<u8>,
        }
        /// // send_ct ////
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NoHeaderReceived {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HeaderReceived {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub hdr: ::prost::alloc::vec::Vec<u8>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EkReceived {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub hdr: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "4")]
            pub ek: ::prost::alloc::vec::Vec<u8>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct1Sent {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub hdr: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "4")]
            pub es: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "5")]
            pub ct1: ::prost::alloc::vec::Vec<u8>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct1SentEkReceived {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
            #[prost(bytes = "vec", tag = "3")]
            pub es: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "4")]
            pub ek: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "5")]
            pub ct1: ::prost::alloc::vec::Vec<u8>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct2Sent {
            #[prost(uint64, tag = "1")]
            pub epoch: u64,
            #[prost(message, optional, tag = "2")]
            pub auth: ::core::option::Option<super::super::Authenticator>,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Chunked {}
    /// Nested message and enum types in `Chunked`.
    pub mod chunked {
        /// // send_ek ////
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct KeysUnsampled {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::KeysUnsampled>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct KeysSampled {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::HeaderSent>,
            #[prost(message, optional, tag = "2")]
            pub sending_hdr: ::core::option::Option<super::super::PolynomialEncoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HeaderSent {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::EkSent>,
            #[prost(message, optional, tag = "2")]
            pub sending_ek: ::core::option::Option<super::super::PolynomialEncoder>,
            #[prost(message, optional, tag = "3")]
            pub receiving_ct1: ::core::option::Option<super::super::PolynomialDecoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct1Received {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::EkSentCt1Received>,
            #[prost(message, optional, tag = "2")]
            pub sending_ek: ::core::option::Option<super::super::PolynomialEncoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EkSentCt1Received {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::EkSentCt1Received>,
            #[prost(message, optional, tag = "3")]
            pub receiving_ct2: ::core::option::Option<super::super::PolynomialDecoder>,
        }
        /// // send_ct ////
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NoHeaderReceived {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::NoHeaderReceived>,
            #[prost(message, optional, tag = "2")]
            pub receiving_hdr: ::core::option::Option<super::super::PolynomialDecoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HeaderReceived {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::HeaderReceived>,
            #[prost(message, optional, tag = "2")]
            pub receiving_ek: ::core::option::Option<super::super::PolynomialDecoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct1Sampled {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::Ct1Sent>,
            #[prost(message, optional, tag = "2")]
            pub sending_ct1: ::core::option::Option<super::super::PolynomialEncoder>,
            #[prost(message, optional, tag = "3")]
            pub receiving_ek: ::core::option::Option<super::super::PolynomialDecoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EkReceivedCt1Sampled {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::Ct1SentEkReceived>,
            #[prost(message, optional, tag = "2")]
            pub sending_ct1: ::core::option::Option<super::super::PolynomialEncoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct1Acknowledged {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::Ct1Sent>,
            #[prost(message, optional, tag = "2")]
            pub receiving_ek: ::core::option::Option<super::super::PolynomialDecoder>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ct2Sampled {
            #[prost(message, optional, tag = "1")]
            pub uc: ::core::option::Option<super::unchunked::Ct2Sent>,
            #[prost(message, optional, tag = "2")]
            pub sending_ct2: ::core::option::Option<super::super::PolynomialEncoder>,
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum InnerState {
        /// // send_ek ////
        #[prost(message, tag = "1")]
        KeysUnsampled(chunked::KeysUnsampled),
        #[prost(message, tag = "2")]
        KeysSampled(chunked::KeysSampled),
        #[prost(message, tag = "3")]
        HeaderSent(chunked::HeaderSent),
        #[prost(message, tag = "4")]
        Ct1Received(chunked::Ct1Received),
        #[prost(message, tag = "5")]
        EkSentCt1Received(chunked::EkSentCt1Received),
        /// // send_ct ////
        #[prost(message, tag = "6")]
        NoHeaderReceived(chunked::NoHeaderReceived),
        #[prost(message, tag = "7")]
        HeaderReceived(chunked::HeaderReceived),
        #[prost(message, tag = "8")]
        Ct1Sampled(chunked::Ct1Sampled),
        #[prost(message, tag = "9")]
        EkReceivedCt1Sampled(chunked::EkReceivedCt1Sampled),
        #[prost(message, tag = "10")]
        Ct1Acknowledged(chunked::Ct1Acknowledged),
        #[prost(message, tag = "11")]
        Ct2Sampled(chunked::Ct2Sampled),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chain {
    #[prost(enumeration = "Direction", tag = "1")]
    pub direction: i32,
    #[prost(uint64, tag = "2")]
    pub current_epoch: u64,
    #[prost(message, repeated, tag = "3")]
    pub links: ::prost::alloc::vec::Vec<chain::Epoch>,
    #[prost(bytes = "vec", tag = "4")]
    pub next_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "5")]
    pub send_epoch: u64,
    #[prost(message, optional, tag = "6")]
    pub params: ::core::option::Option<ChainParams>,
}
/// Nested message and enum types in `Chain`.
pub mod chain {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Epoch {
        #[prost(message, optional, tag = "1")]
        pub send: ::core::option::Option<epoch::EpochDirection>,
        #[prost(message, optional, tag = "2")]
        pub recv: ::core::option::Option<epoch::EpochDirection>,
    }
    /// Nested message and enum types in `Epoch`.
    pub mod epoch {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EpochDirection {
            #[prost(uint32, tag = "1")]
            pub ctr: u32,
            #[prost(bytes = "vec", tag = "2")]
            pub next: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "3")]
            pub prev: ::prost::alloc::vec::Vec<u8>,
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChainParams {
    /// Disallow requesting a key that is more than MAX_JUMP ahead of `ctr`.
    /// If zero, defaults to 25,000.
    #[prost(uint32, tag = "1")]
    pub max_jump: u32,
    /// Keep around keys back to at least `ctr - MAX_OOO_KEYS`, in case an out-of-order
    /// message comes in.  Messages older than this that arrive out-of-order
    /// will not be able to be decrypted and will return Error::KeyTrimmed.
    #[prost(uint32, tag = "2")]
    pub max_ooo_keys: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Version {
    /// disabled
    V0 = 0,
    V1 = 1,
}
impl Version {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::V0 => "V_0",
            Self::V1 => "V_1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "V_0" => Some(Self::V0),
            "V_1" => Some(Self::V1),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    A2B = 0,
    B2A = 1,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::A2B => "A_2_B",
            Self::B2A => "B_2_A",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "A_2_B" => Some(Self::A2B),
            "B_2_A" => Some(Self::B2A),
            _ => None,
        }
    }
}
